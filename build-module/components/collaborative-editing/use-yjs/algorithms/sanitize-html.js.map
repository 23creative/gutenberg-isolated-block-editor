{"version":3,"sources":["../../../../../src/components/collaborative-editing/use-yjs/algorithms/sanitize-html.js"],"names":["remove","sanitizeHTML","html","body","document","implementation","createHTMLDocument","innerHTML","elements","getElementsByTagName","elementIndex","length","found","element","tagName","attributeIndex","attributes","name","key","startsWith","removeAttribute"],"mappings":"AAAA,SAASA,MAAT,QAAuB,gBAAvB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,YAAT,CAAuBC,IAAvB,EAA8B;AAC5C,QAAM;AAAEC,IAAAA;AAAF,MAAWC,QAAQ,CAACC,cAAT,CAAwBC,kBAAxB,CAA4C,EAA5C,CAAjB;AACAH,EAAAA,IAAI,CAACI,SAAL,GAAiBL,IAAjB;AACA,QAAMM,QAAQ,GAAGL,IAAI,CAACM,oBAAL,CAA2B,GAA3B,CAAjB;AACA,MAAIC,YAAY,GAAGF,QAAQ,CAACG,MAA5B;AACA,MAAIC,KAAK,GAAG,CAAZ;;AAEA,SAAQF,YAAY,EAApB,EAAyB;AACxB,UAAMG,OAAO,GAAGL,QAAQ,CAAEE,YAAF,CAAxB;;AAEA,QAAKG,OAAO,CAACC,OAAR,KAAoB,QAAzB,EAAoC;AACnCF,MAAAA,KAAK;AACLZ,MAAAA,MAAM,CAAEa,OAAF,CAAN;AACA,KAHD,MAGO;AACN,UAAIE,cAAc,GAAGF,OAAO,CAACG,UAAR,CAAmBL,MAAxC;;AAEA,aAAQI,cAAc,EAAtB,EAA2B;AAC1B,cAAM;AAAEE,UAAAA,IAAI,EAAEC;AAAR,YAAgBL,OAAO,CAACG,UAAR,CAAoBD,cAApB,CAAtB;;AAEA,YAAKG,GAAG,CAACC,UAAJ,CAAgB,IAAhB,CAAL,EAA8B;AAC7BP,UAAAA,KAAK;AACLC,UAAAA,OAAO,CAACO,eAAR,CAAyBF,GAAzB;AACA;AACD;AACD;AACD;;AAED,SAAON,KAAK,GAAGT,IAAI,CAACI,SAAR,GAAoBL,IAAhC;AACA","sourcesContent":["import { remove } from '@wordpress/dom';\n\n// TODO: Unsolved problem\n// The limitation in our sanitization strategy is that it does not match the\n// server-side wp_kses rules, which should be considered the canonical config\n// of how unsafe the site owner is willing to be. On sites that do allow script tags,\n// this crude sanitization strategy could wipe out those tags if a peer joined\n// and re-saved their sanitized content.\n//\n// The ideal solution would be for block authors to make sure that any arbitrary code\n// is run through wp_kses before executing.\n\n/**\n * Strips scripts and on* attributes from HTML.\n *\n * Slightly modified version of wp.dom.safeHTML() that only alters the\n * HTML if it actually finds nodes/attributes to remove. This is so we can leave\n * invalid HTML intact, for example if a user is still in the middle of typing the HTML string.\n *\n * @param {string} html HTML to sanitize.\n *\n * @return {string} The sanitized HTML.\n */\nexport default function sanitizeHTML( html ) {\n\tconst { body } = document.implementation.createHTMLDocument( '' );\n\tbody.innerHTML = html;\n\tconst elements = body.getElementsByTagName( '*' );\n\tlet elementIndex = elements.length;\n\tlet found = 0;\n\n\twhile ( elementIndex-- ) {\n\t\tconst element = elements[ elementIndex ];\n\n\t\tif ( element.tagName === 'SCRIPT' ) {\n\t\t\tfound++;\n\t\t\tremove( element );\n\t\t} else {\n\t\t\tlet attributeIndex = element.attributes.length;\n\n\t\t\twhile ( attributeIndex-- ) {\n\t\t\t\tconst { name: key } = element.attributes[ attributeIndex ];\n\n\t\t\t\tif ( key.startsWith( 'on' ) ) {\n\t\t\t\t\tfound++;\n\t\t\t\t\telement.removeAttribute( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found ? body.innerHTML : html;\n}\n"],"file":"sanitize-html.js"}